name: Deploy to Dev

on:
  workflow_dispatch:
    inputs:
      deploy_terraform:
        description: 'Deploy Terraform infrastructure'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_lambda:
        description: 'Deploy Lambda functions'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deploy_eks:
        description: 'Deploy EKS services'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - 'lambda/**'
      - 'docker/**'
      - 'kubernetes/**'
      - '.github/workflows/deploy-dev.yml'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-central-1
  ECR_REGISTRY: 920120424621.dkr.ecr.eu-central-1.amazonaws.com
  EKS_CLUSTER: casestudy2-dev-eks

jobs:
  terraform:
    name: Terraform Deploy
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deploy_terraform != 'false' }}
    outputs:
      eks_cluster_name: ${{ steps.tf-output.outputs.eks_cluster_name }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::920120424621:role/githubrepo
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          
      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init
        
      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan -out=tfplan
          terraform show -no-color tfplan > plan.txt
          
      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/plan.txt
          retention-days: 7
          
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan
        
      - name: Get Terraform Outputs
        id: tf-output
        working-directory: ./terraform
        run: |
          echo "eks_cluster_name=$(terraform output -raw eks_cluster_name)" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: terraform
    if: |
      always() && 
      (needs.terraform.result == 'success' || needs.terraform.result == 'skipped') &&
      github.event.inputs.deploy_eks != 'false'
    strategy:
      matrix:
        service: [soar-api, soar-processor, soar-remediation]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::920120424621:role/githubrepo
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build, tag, and push image
        working-directory: ./docker/${{ matrix.service }}
        run: |
          IMAGE_TAG=${{ github.sha }}
          docker build -t ${{ env.ECR_REGISTRY }}/casestudy2/dev/${{ matrix.service }}:$IMAGE_TAG .
          docker tag ${{ env.ECR_REGISTRY }}/casestudy2/dev/${{ matrix.service }}:$IMAGE_TAG \
                     ${{ env.ECR_REGISTRY }}/casestudy2/dev/${{ matrix.service }}:latest
          docker push ${{ env.ECR_REGISTRY }}/casestudy2/dev/${{ matrix.service }}:$IMAGE_TAG
          docker push ${{ env.ECR_REGISTRY }}/casestudy2/dev/${{ matrix.service }}:latest

  deploy-lambda:
    name: Deploy Lambda Functions
    runs-on: ubuntu-latest
    needs: terraform
    if: |
      always() && 
      (needs.terraform.result == 'success' || needs.terraform.result == 'skipped') &&
      github.event.inputs.deploy_lambda != 'false'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::920120424621:role/githubrepo
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Package and Deploy Lambda Functions
        run: |
          for lambda_dir in lambda/*/; do
            lambda_name=$(basename $lambda_dir)
            echo "Packaging $lambda_name..."
            cd $lambda_dir
            pip install -r requirements.txt -t .
            zip -r ${lambda_name}.zip . -x "*.pyc" -x "__pycache__/*"
            
            echo "Updating Lambda function: casestudy2-dev-${lambda_name}"
            aws lambda update-function-code \
              --function-name casestudy2-dev-${lambda_name} \
              --zip-file fileb://${lambda_name}.zip \
              --region ${{ env.AWS_REGION }} || echo "Lambda update failed for ${lambda_name}"
            
            cd ../..
          done

  deploy-eks:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [terraform, build-and-push]
    if: |
      always() && 
      (needs.terraform.result == 'success' || needs.terraform.result == 'skipped') &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped') &&
      github.event.inputs.deploy_eks != 'false'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::920120424621:role/githubrepo
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}
          
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f kubernetes/namespace.yaml
          kubectl apply -f kubernetes/service-account.yaml
          kubectl apply -f kubernetes/soar-api-deployment.yaml
          kubectl apply -f kubernetes/soar-processor-deployment.yaml
          kubectl apply -f kubernetes/soar-remediation-deployment.yaml
          kubectl apply -f kubernetes/ingress.yaml
          
      - name: Deploy Monitoring Stack
        run: |
          kubectl apply -f kubernetes/prometheus.yaml
          kubectl apply -f kubernetes/grafana.yaml
          
      - name: Restart Deployments
        run: |
          kubectl rollout restart deployment/soar-api -n soar-system
          kubectl rollout restart deployment/soar-processor -n soar-system
          kubectl rollout restart deployment/soar-remediation -n soar-system
          
      - name: Wait for Deployments
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/soar-api -n soar-system
          kubectl wait --for=condition=available --timeout=300s deployment/soar-processor -n soar-system
          kubectl wait --for=condition=available --timeout=300s deployment/soar-remediation -n soar-system
          
      - name: Get Endpoints
        run: |
          echo "=== DEPLOYMENT SUMMARY ==="
          echo "=== SOAR API Service ==="
          kubectl get svc soar-api -n soar-system
          echo ""
          echo "=== Internal ALB (for Lambda) ==="
          kubectl get ingress soar-alb -n soar-system -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n soar-system
          echo ""
          echo "=== Grafana Monitoring ==="
          kubectl get svc grafana -n monitoring
          echo ""
          echo "=== Lambda Functions ==="
          aws lambda list-functions --query "Functions[?starts_with(FunctionName, 'casestudy2-dev')].{Name:FunctionName,Runtime:Runtime,Status:State}" --output table
          echo ""
          echo "=== VPC Endpoints ==="
          aws ec2 describe-vpc-endpoints --filters "Name=tag:Name,Values=casestudy2-dev-*" --query "VpcEndpoints[].{Service:ServiceName,State:State}" --output table

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [terraform, build-and-push, deploy-lambda, deploy-eks]
    if: always()
    
    steps:
      - name: Deployment Success
        if: ${{ needs.deploy-eks.result == 'success' }}
        run: |
          echo "‚úÖ Deployment to Dev environment successful!"
          echo ""
          echo "üèóÔ∏è  Infrastructure Details:"
          echo "   EKS Cluster: ${{ env.EKS_CLUSTER }}"
          echo "   Region: ${{ env.AWS_REGION }}"
          echo ""
          echo "üîß Components Deployed:"
          echo "   ‚úì Terraform Infrastructure"
          echo "   ‚úì Lambda Functions (Parser, Engine, Notify, Remediate)"
          echo "   ‚úì EKS Deployments (SOAR API, Processor, Remediation)"
          echo "   ‚úì Monitoring Stack (Prometheus, Grafana)"
          echo ""
          echo "üìä Access Points:"
          echo "   ‚Ä¢ Internal ALB: Check kubectl output above"
          echo "   ‚Ä¢ Client VPN: Required for monitoring access"
          echo "   ‚Ä¢ Lambda Flow: EventBridge ‚Üí SQS ‚Üí Lambda ‚Üí ALB ‚Üí EKS"
          echo ""
          echo "üîç Next Steps:"
          echo "   1. Connect to Client VPN"
          echo "   2. Access Grafana for monitoring"
          echo "   3. Test Lambda flow with sample event"
          echo "   4. Verify VPC endpoints are working"
          
      - name: Deployment Failed
        if: ${{ needs.deploy-eks.result == 'failure' }}
        run: |
          echo "‚ùå Deployment to Dev environment failed!"
          exit 1
